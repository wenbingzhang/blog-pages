[{"id":0,"href":"/notes/2024/06/06/sf4ff6x8cuyhvzougj9dwg/","title":"📝 MacOS签名","section":"📔 C++","content":" 下载根证书 # https://www.apple.com/certificateauthority/DeveloperIDG2CA.cer\n导入根证书 # sudo security import ~/Downloads/DeveloperIDG2CA.cer \\ -k /Library/Keychains/System.keychain \\ -T /usr/bin/codesign \\ -T /usr/bin/security \\ -T /usr/bin/productbuild 查看和清理特殊属性 # xattr -lr xxx.app xattr -cr xxx.app 签发APP # codesign --deep --force --verbose --sign \u0026#34;xxxx\u0026#34; xxx.app 验证签名 # spctl --assess --type execute --verbose=4 xxx.app 参考文档 # https://testerhome.com/topics/33338\nhttps://www.apple.com/certificateauthority/\nhttps://www.jianshu.com/p/f420649fba42\n"},{"id":1,"href":"/notes/2024/03/11/j3c62fv8dglvf2kg975zlv/","title":"📝 标签操作","section":"📔 Git","content":" 创建标签 # git tag \u0026lt;tagname\u0026gt; 推送标签到远程仓库 # git push origin \u0026lt;tagname\u0026gt; 推送所有标签到远程仓库 # git push origin --tags 查看本地所有标签 # git tag 查看远程所有标签 # git ls-remote --tags origin 删除本地或远程标签 # git tag -d \u0026lt;tagname\u0026gt; # 删除远程标签 git push origin :refs/tags/\u0026lt;tagname\u0026gt; "},{"id":2,"href":"/notes/2024/03/06/kkcc5t2y88hybafpourudv/","title":"📝 FFmpeg检测透明通道","section":"🔖 常用命令","content":" 检测透明通道 # FFmpeg命令 # $ ffmpeg -v error -i 123.mp4 -vf \u0026#34;select=\u0026#39;eq(n,0)\u0026#39;, alphaextract\u0026#34; -f null /dev/null [Parsed_alphaextract_1 @ 0x7fe8f5208100] Requested planes not available. [Parsed_alphaextract_1 @ 0x7fe8f5208100] Failed to configure input pad on Parsed_alphaextract_1 [vf#0:0 @ 0x7fe8f5005f40] Error reinitializing filters! Failed to inject frame into filter network: Invalid argument Error while filtering: Invalid argument [out#0/null @ 0x7fe8f5004900] Nothing was written into output file, because at least one of its streams received no packets. 判断条件 # 如果出现以上报错信息，则说明视频中没有透明通道。\n"},{"id":3,"href":"/notes/2024/03/06/e3ksq3zkmps14gcxuirwzx/","title":"📝 所有权","section":"🔖 学习笔记","content":" 所有权 # 所有权规则 # Rust 中的每一个值都有一个 所有者（owner）。 值在任一时刻有且只有一个所有者。 当所有者（变量）离开作用域，这个值将被丢弃。 可Copy的类型 # 所有整数类型，比如 u32 。 布尔类型，bool ，它的值是 true 和 false 。 所有浮点数类型，比如 f64 。 字符类型，char 。 元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，(i32, i32) 实现了 Copy ，但(i32, String) 就没有。 "},{"id":4,"href":"/notes/2024/05/28/3txbbb7iruppjsg4p7rwnb/","title":"📝 MacOS堆栈大小","section":"📔 C++","content":" 问题代码 # char buffer[8*1024*1024]; 问题分析 # macos系统默认的堆栈大小为8MB，可以通过ulimit命令查看和修改。 但是，如果代码中使用了大量的堆栈变量，可能会导致栈溢出，导致程序崩溃。 # 查看系统默认的堆栈大小 ulimit -a # 或者 ulimit -s 解决方案 # char *buffer = new char[8*1024*1024]; // 记得释放 delete[] buffer; "},{"id":5,"href":"/notes/2024/03/14/5kqlzqjqawbxf2t6vusxar/","title":"📝 删除Commit","section":"📔 Git","content":"# 获取commit信息 git log # commit-id 要删除commit的下一个commit-id git rebase -i (commit-id) # 编辑文件，将要删除的commit之前的pick改为drop # 保存文件退出 # 再次查看commit信息，确认删除成功 git log "},{"id":6,"href":"/notes/2024/03/06/o4arkqgfnqygr5ckif2gkk/","title":"📝 借用与引用","section":"🔖 学习笔记","content":" 借用与引用 # 创建一个引用的行为称为 借用 允许使用值但不获取其所有权 引用规则 # 在任意给定时间，要么 只能有一个可变引用，要么 只能有多个不可变引用。 引用必须总是有效的。 可变引用 # 允许修改一个借用的值，这就是可变引用（\u0026amp;mut）。\nfn main() { let mut s = String::from(\u0026#34;hello\u0026#34;); change(\u0026amp;mut s); } fn change(some_string: \u0026amp;mut String) { some_string.push_str(\u0026#34;, world\u0026#34;); } 悬垂引用（Dangling References） # fn main() { let reference_to_nothing = dangle(); } fn dangle() -\u0026gt; \u0026amp;String { // dangle 返回一个字符串的引用 let s = String::from(\u0026#34;hello\u0026#34;); // s 是一个新字符串 \u0026amp;s // 返回字符串 s 的引用 } // 这里 s 离开作用域并被丢弃。其内存被释放。 // 危险！ "},{"id":7,"href":"/notes/2020/12/22/ros_kibgg/","title":"📝 FFmpeg规范音频响度","section":"🔖 常用命令","content":" 通过FFmpeg内置滤镜、手动调整音量、或者ffmpeg-normalize实现对响度的控制。\n内置归一化滤波器 # loudnorm：通过EBU R.128进行响度标准化。您可以设置积分的体积目标，体积范围目标或最大真实峰。建议用于发布音频和视频，并被世界各地的广播公司使用。\ndynaudnorm：“智能”响度归一化，不进行裁剪。动态地将规范化应用于文件的窗口部分。应谨慎使用，因为这可能会改变声音的特性。\n#fdk_aac编码器 ffmpeg200421 -i \u0026#34;source_audio.ts\u0026#34; -c:a libfdk_aac -strict -2 -ac 2 -ar 48000 -ab 196k -af \u0026#34;[0:a]pan=stereo| FL \u0026lt; FL + 0.5*FC + 0.6*BL + 0.6*SL | FR \u0026lt; FR + 0.5*FC + 0.6*BR + 0.6*SR,loudnorm=I=-23:LRA=6:tp=-1\u0026#34; -y -cutoff 20000 \u0026#34;ac_5m.ts\u0026#34; #aac编码器 ffmpeg -i \u0026#34;source_audio.ts\u0026#34; -c:a aac -strict -2 -ac 2 -ar 48000 -ab 196k -af \u0026#34;loudnorm=I=-23:LRA=6:tp=-1\u0026#34; -y -cutoff 20000 \u0026#34;1_aac_dynaudnorm_ac_5m.ts\u0026#34; 常用方式 # ffmpeg -i input.mp4 -vn -acodec libfdk_aac -ac 2 -ar 44100 -af loudnorm=I=-16:TP=-1:LRA=7:print_format=json -f null /dev/null 手动规范音频的响度 # 首先，您需要分析音频流以获取最大音量，以查看规范化是否起作用。\nffmpeg -i video.avi -af \u0026#34;volumedetect\u0026#34; -vn -sn -dn -f null /dev/null [Parsed_volumedetect_0 @ 0x7f8ba1c121a0] mean_volume: -16.0 dB [Parsed_volumedetect_0 @ 0x7f8ba1c121a0] max_volume: -5.0 dB [Parsed_volumedetect_0 @ 0x7f8ba1c121a0] histogram_0db: 87861 使用音量过滤器（volume）\nffmpeg -i video.mp4 -af \u0026#34;volume=5dB\u0026#34; -c:v copy -c:a aac -cutoff 20000 output.mp4 volume=5dB 表示增加5分贝的音量\nvolume=-5dB 表示减少5分贝的音量\nvolume=1.5 表示放大1.5倍的音量\nffmpeg-normalize # ffmpeg-normalize 是一个Python库，可以使用pip安装，详细的使用方式在github上有文档，这里就不做过多的介绍了。\n"},{"id":8,"href":"/notes/2020/12/07/aaelfz1mg/","title":"📝 MacOS Lauchpad(启动台) 重置","section":"📔 MacOS","content":" 重置macos的Lauchpad(启动台)，及设置Lauchpad(启动台)的行数和列数。\n打开终端程序，按需求执行以下命令即可。\n重置 Lauchpad # defaults write com.apple.dock ResetLaunchPad -bool TRUE; 重启 Dock # killall Dock 设置 Lauchpad 图标的列数 # defaults write com.apple.dock springboard-columns -int 7 设置 Lauchpad 图标的行数 # defaults write com.apple.dock springboard-rows -int 7 "},{"id":9,"href":"/notes/2020/10/13/mv3bzfgqm/","title":"📝 FFmpeg多个音频混音","section":"🔖 常用命令","content":" 使用FFmpeg中的adelay和amix滤镜给音频做混音\n在30秒后混合1个音频\nffmpeg -i 1-1.mp3 -i 2.mp3 -filter_complex \u0026#34;[1]adelay=delays=30s:all=1[aud1];[0][aud1]amix=inputs=2\u0026#34; -vsync 2 -y 3.mp3 在30秒后混合2个音频\nffmpeg -i 1-1.mp3 -i 2.mp3 -i 3.mp3 -filter_complex \u0026#34;[1]adelay=delays=30s:all=1[aud1];[2]adelay=delays=30s:all=1[aud2];[0][aud1][aud2]amix=inputs=3\u0026#34; -vsync 2 -y 4.mp3 混合多个参照混合2个的命令修改下即可\n"},{"id":10,"href":"/notes/2020/04/01/misev5_hw/","title":"📝 upx for macos 之源码编译","section":"📔 MacOS","content":" UPX (the Ultimate Packer for eXecutables)是一款先进的可执行程序文件压缩器，压缩过的可执行文件体积缩小50%-70% ，这样减少了磁盘占用空间、网络上传下载的时间和其它分布以及存储费用。\n准备源码 # git clone https://github.com/upx/upx.git git clone https://github.com/upx/upx-lzma-sdk.git lzma-sdk wget http://www.oberhumer.com/opensource/ucl/download/ucl-1.03.tar.gz 编译源码 # tar -xzvf ucl-1.03.tar.gz cd ucl-1.03 ./configure --prefix=/home/o/ucl CC=clang make cd ../upx make all UPX_UCLDIR=../ucl-1.03 UPX_LZMADIR=../lzma-sdk 编译完成之后再src目录下能找到upx.out文件就成功了\n"},{"id":11,"href":"/notes/2020/07/15/uthueryud/","title":"📝 FFmpeg给视频添加水印","section":"🔖 常用命令","content":" 图片水印、文字水印、画中画\n图片水印 # ffmpeg -i input.mp4 -vf \u0026#34;movie=wenzi.png[watermark];[in][watermark] overlay=main_w-overlay_w-10:main_h-overlay_h-10[out] \u0026#34; output.mp4 -i: 一般表示输入 input.mp4表示要处理的视频源 -vf: 滤镜相关，视频裁剪，水印等等操作都需要它完成 movie: wenzi.png 要添加的水印图片地址 overlay: 水印参数 main_w-overlay_w-10: 水印在x轴的位置，也可以写成x=main_w-overlay_w-10 main_h-overlay_h-10: 水印在y轴的位置 ffmpeg -i input.mp4 -i logo.png -filter_complex \u0026#39;overlay=x=10:y=main_h-overlay_h-10\u0026#39; output.mp4 -filter_complex: 相比-vf, filter_complex适合开发复杂的滤镜功能，如同时对视频进行裁剪并旋转。参数之间使用逗号（，）隔开即可 main_w: 视频宽度 overlay_w: 要添加的图片水印宽度 main_h: 视频高度 overlay_h: 要添加的图片水印宽度 文字水印 # ffmpeg -i input.mp4 -vf \u0026#34;drawtext=fontfile=simhei.ttf: text=‘技术是第一生产力’:x=10:y=10:fontsize=24:fontcolor=white:shadowy=2\u0026#34; output.mp4 fontfile: 字体类型 text: 要添加的文字内容 fontsize: 字体大小 fontcolor: 字体颜色 画中画 # 只显示1遍，后边重复显示最后一帧。\nffmpeg -i bunny.mp4 -vf \u0026#34;movie=test.mov[logo];[0:v][logo]overlay=x=100:y=100\u0026#34; -y out.mp4 mov一直循环显示。 添加 loop=0,setpts=N/FRAME_RATE/TB 即可。\nffmpeg -i bunny.mp4 -vf \u0026#34;movie=test.mov:loop=0,setpts=N/FRAME_RATE/TB[logo];[0:v][logo]overlay=x=100:y=100\u0026#34; -y out.mp4 只显示一遍 添加eof_action即可。\nffmpeg -i bunny.mp4 -vf \u0026#34;movie=test.mov[logo];[0:v][logo]overlay=x=100:y=100:eof_action=pass\u0026#34; -vframes 1000 -y out.mp4 "},{"id":12,"href":"/notes/2019/01/03/hjvndli-4/","title":"📝 MacOS恢复launchpad默认布局","section":"📔 MacOS","content":" 在Mac OS 中重置Launchpad布局\nLaunchpad可以作为从熟悉的类似iOS的图标网格界面在Mac上打开应用程序的快捷方式。如果您已经自定义了这些应用程序图标并在Launchpad中进行了排列，那么您可能会决定从头开始并将其顺序重置为首次购买Mac时的显示方式。如果要重新排列Launchpad图标的显示方式，这也很有用，但使用Launchpad解决某些显示错误也很有帮助，尤其是在图标未显示或显示不正确的情况下。\n在OS X的早期版本中，用户可以通过转储一些数据库文件来刷新Launchpad内容，但在Mac OS和OS X\n10.10.x以后，您需要使用默认命令字符串来重置Launchpad内容和布局代替。\n如何在MacOS中重置Launchpad布局\n打开终端应用程序并输入以下默认值写入命令字符串：\ndefaults write com.apple.dock ResetLaunchPad -bool true; killall Dock 点击返回并等待Dock重新启动并重启Launchpad\n再次打开Launchpad时，布局将恢复为默认状态，将所有捆绑的应用程序放在Launchpad的第一个屏幕上，将第三方应用程序放到辅助（以及第三个，如果适用）屏幕上。\n您现在可以根据需要重新排列Launchpad的图标和布局，或者只在第一个屏幕上保留Apple应用程序的默认布局，在后面的屏幕上添加第三方应用程序和添加内容。\n这个默认的命令字符串是在stackexchange上找到的，虽然提到它的用户仍然列出旧的数据库转储技巧作为必要的步骤 - 在测试中，后面的\nLaunchpad数据库删除命令不需要简单地重置OS X中的Launchpad布局Yosemite 10.10 .x +。\n"},{"id":13,"href":"/notes/2020/05/13/rdgqnfi6j/","title":"📝 FFprobe详解","section":"🔖 常用命令","content":" ffprobe是ffmpeg提供的三大工具之一，用来查看音视频文件的各种信息，比如：封装格式、音频/视频流信息、数据包信息等。\nffprobe的源码是ffprobe.c，开发过程中如果想获取ffprobe查看的信息，可以通过分析源码，获得对应字段。\n本文主要介绍format、stream、Packet和Frame信息，包含每个字段的说明以及对应的ffmpeg字段。\n查看音视频文件的封装格式 # ffprobe -show_format inputFile 输出信息：\n[FORMAT] // 文件名 filename=VID_20190811_113717.mp4 // 容器中流的个数，即AVFormatContext-\u0026gt;nb_streams nb_streams=2 // 即AVFormatContext-\u0026gt;nb_programs nb_programs=0 // 封装格式，即AVFormatContext-\u0026gt;iformat-\u0026gt;name format_name=mov,mp4,m4a,3gp,3g2,mj2 // 即AVFormatContext-\u0026gt;iformat-\u0026gt;long_name format_long_name=QuickTime / MOV // 即AVFormatContext-\u0026gt;start_time，基于AV_TIME_BASE_Q，换算为秒 start_time=0.000000 // 即AVFormatContext-\u0026gt;duration，基于AV_TIME_BASE_Q，换算为秒 duration=10.508000 // 单位字节，即avio_size(AVFormatContext-\u0026gt;pb) size=27263322 // 码率，即AVFormatContext-\u0026gt;bit_rate bit_rate=20756240 // 即AVFormatContext-\u0026gt;probe_score probe_score=100 [/FORMAT] 查看音视频文件的流信息 # ffprobe -show_streams inputFile 输出信息：\n[STREAM] // 当前流的索引信息,对应于AVStream-\u0026gt;index index=0 // AVCodecDescriptor * cd = avcodec_descriptor_get(AVStream-\u0026gt;codecpar-\u0026gt;codec_id) // 编码名称，即cd-\u0026gt;name codec_name=h264 // 编码全称，即cd-\u0026gt;long_name codec_long_name=H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 // 一个编码参数，可以为Baseline、Main、High等，Baseline无B帧，Main及以后可以包含B帧 // 通过avcodec_profile_name(AVStream-\u0026gt;codecpar-\u0026gt;codec_id, AVStream-\u0026gt;codecpar-\u0026gt;profile)获得 profile=High // 流类型，即av_get_media_type_string(AVStream-\u0026gt;codecpar-\u0026gt;codec_type) codec_type=video // 即AVStream-\u0026gt;codec-\u0026gt;time_base codec_time_base=14777/877500 // 通过宏av_fourcc2str(AVStream-\u0026gt;codecpar-\u0026gt;codec_tag)获得 codec_tag_string=avc1 // 对应AVStream-\u0026gt;codecpar-\u0026gt;codec_tag codec_tag=0x31637661 // 有效区域的宽度，即AVStream-\u0026gt;codecpar-\u0026gt;width width=1920 // 有效区域的高度，即AVStream-\u0026gt;codecpar-\u0026gt;height height=1080 // 视频帧宽度，可能与上面的宽度不同，即AVStream-\u0026gt;codec-\u0026gt;coded_width，例如：当解码帧在输出前裁剪或启用低分辨率时 coded_width=1920 // 视频帧高度，可能与上面的高度不同，即AVStream-\u0026gt;codec-\u0026gt;coded_height，例如：当解码帧在输出前裁剪或启用低分辨率时 coded_height=1088 // 视频的延迟帧数，即AVStream-\u0026gt;codecpar-\u0026gt;video_delay has_b_frames=0 // sar，图像采集时，横向采集点数与纵向采集点数的比例 // FFmpeg提供了多个sar：AVStream-\u0026gt;sample_aspect_ratio、AVStream-\u0026gt;codecpar-\u0026gt;sample_aspect_ratio、AVFrame-\u0026gt;sample_aspect_ratio // 通过av_guess_sample_aspect_ratio获取最终的sar sample_aspect_ratio=1:1 // dar，真正展示的图像宽高比，在渲染视频时，必须根据这个比例进行缩放 // 通过av_reduce计算得到，par * sar = dar display_aspect_ratio=16:9 // 像素格式，即av_get_pix_fmt_name(AVStream-\u0026gt;codecpar-\u0026gt;format) pix_fmt=yuvj420p // 编码参数，即AVStream-\u0026gt;codecpar-\u0026gt;level level=40 // 额外的色彩空间特征，即av_color_range_name(AVStream-\u0026gt;codecpar-\u0026gt;color_range)，AVCOL_RANGE_MPEG对应tv，AVCOL_RANGE_JPEG对应pc color_range=pc // YUV彩色空间类型，即av_color_space_name(AVStream-\u0026gt;codecpar-\u0026gt;color_space) color_space=bt470bg // 颜色传输特性，即av_color_transfer_name(AVStream-\u0026gt;codecpar-\u0026gt;color_trc) color_transfer=smpte170m // 即av_color_primaries_name(AVStream-\u0026gt;codecpar-\u0026gt;color_primaries) color_primaries=bt470bg // 色度样品的位置，即av_chroma_location_name(AVStream-\u0026gt;codecpar-\u0026gt;chroma_location) chroma_location=left // 交错视频中字段的顺序，即AVStream-\u0026gt;codecpar-\u0026gt;field_order field_order=unknown // av_timecode_make_mpeg_tc_string处理AVStream-\u0026gt;codec-\u0026gt;timecode_frame_start获得 timecode=N/A // 参考帧数量，即AVStream-\u0026gt;codec-\u0026gt;refs refs=1 is_avc=true // 表示用几个字节表示NALU的长度 nal_length_size=4 id=N/A // 当前流的基本帧率，这个值仅是一个猜测，对应于AVStream-\u0026gt;r_frame_rate r_frame_rate=30/1 // 平均帧率，对应于AVStream-\u0026gt;avg_frame_rate avg_frame_rate=438750/14777 // AVStream的时间基准，即AVStream-\u0026gt;time_base time_base=1/90000 // 流开始时间，基于time_base，即AVStream-\u0026gt;start_time start_pts=0 // 转换（start_pts * time_base）之后的开始时间，单位秒 start_time=0.000000 // 流时长，基于time_base，即AVStream-\u0026gt;duration duration_ts=945728 // 转换（duration_ts * time_base）之后的时长，单位秒 duration=10.508089 // 码率，即AVStream-\u0026gt;codecpar-\u0026gt;bit_rate bit_rate=19983544 // 最大码率，即AVStream-\u0026gt;codec-\u0026gt;rc_max_rate max_bit_rate=N/A // Bits per sample/pixel，即AVStream-\u0026gt;codec-\u0026gt;bits_per_raw_sample bits_per_raw_sample=8 // 视频流中的帧数，即AVStream-\u0026gt;nb_frames nb_frames=312 nb_read_frames=N/A nb_read_packets=N/A // 下面TAG为AVStream-\u0026gt;metadata中的信息 // 逆时针的旋转角度（相当于正常视频的逆时针旋转角度） TAG:rotate=90 // 创建时间 TAG:creation_time=2019-08-11T03:37:28.000000Z // 语言 TAG:language=eng TAG:handler_name=VideoHandle // SIDE_DATA为AVStream-\u0026gt;side_data数据 [SIDE_DATA] // side_data数据类型，Display Matrix表示一个3*3的矩阵，这个矩阵需要应用到解码后的视频帧上，才能正确展示 side_data_type=Display Matrix displaymatrix= 00000000: 0 65536 0 00000001: -65536 0 0 00000002: 0 0 1073741824 // 顺时针旋转90度还原视频 rotation=-90 [/SIDE_DATA] [/STREAM] [STREAM] // 当前流的索引信息,对应于AVStream-\u0026gt;index index=1 // AVCodecDescriptor * cd = avcodec_descriptor_get(AVStream-\u0026gt;codecpar-\u0026gt;codec_id) // 编码名称，即cd-\u0026gt;name codec_name=aac // 编码全称，即cd-\u0026gt;long_name codec_long_name=AAC (Advanced Audio Coding) // 通过avcodec_profile_name(AVStream-\u0026gt;codecpar-\u0026gt;codec_id, AVStream-\u0026gt;codecpar-\u0026gt;profile)获得 profile=LC // 流类型，即av_get_media_type_string(AVStream-\u0026gt;codecpar-\u0026gt;codec_type) codec_type=audio // 即AVStream-\u0026gt;codec-\u0026gt;time_base codec_time_base=1/48000 // 通过宏av_fourcc2str(AVStream-\u0026gt;codecpar-\u0026gt;codec_tag)获得 codec_tag_string=mp4a // 对应AVStream-\u0026gt;codecpar-\u0026gt;codec_tag codec_tag=0x6134706d // 采样点格式，通过av_get_sample_fmt_name(AVStream-\u0026gt;codecpar-\u0026gt;format)获取 sample_fmt=fltp // 采样率，即AVStream-\u0026gt;codecpar-\u0026gt;sample_rate sample_rate=48000 // 通道数，即AVStream-\u0026gt;codecpar-\u0026gt;channels channels=2 // 通道布局，与channels是相对应，通过av_bprint_channel_layout获取，stereo表示立体声 channel_layout=stereo // 每个采样点占用多少bit，即av_get_bits_per_sample(par-\u0026gt;codec_id) bits_per_sample=0 id=N/A r_frame_rate=0/0 avg_frame_rate=0/0 // AVStream的时间基准，即AVStream-\u0026gt;time_base time_base=1/48000 // 流开始时间，基于time_base，即AVStream-\u0026gt;start_time start_pts=0 // 转换（start_pts * time_base）之后的开始时间，单位秒 start_time=0.000000 // 流时长，基于time_base，即AVStream-\u0026gt;duration duration_ts=502776 // 转换（duration_ts * time_base）之后的时长，单位秒 duration=10.474500 // 码率，即AVStream-\u0026gt;codecpar-\u0026gt;bit_rate bit_rate=156002 // 最大码率，即AVStream-\u0026gt;codec-\u0026gt;rc_max_rate max_bit_rate=156000 // Bits per sample/pixel，即AVStream-\u0026gt;codec-\u0026gt;bits_per_raw_sample bits_per_raw_sample=N/A // 音频流中的帧数，即AVStream-\u0026gt;nb_frames nb_frames=491 nb_read_frames=N/A nb_read_packets=N/A TAG:creation_time=2019-08-11T03:37:28.000000Z TAG:language=eng TAG:handler_name=SoundHandle [/STREAM] SAR(Sample Aspect Ratio): 采样数宽高比，图像的横向采集点数与纵向采集点数的比值，即像素个数的比值。\nPAR(Pixel Aspect Ratio): 像素宽高比，即每个像素的宽度与高度的比值，所以可以认为像素不是正方形的。\nDAR(Display Aspect Ratio): 显示宽高比，图像最终展示的宽高比，播放器在渲染视频帧时，需要保持DAR的比例。\n它们之间的关系：PAR * SAR = DAR\n如上图所示：每个方格代表一个像素，宽度为5像素，高度为4像素，即SAR=5 : 4\n假设图像的显示宽度为160，高度为120，即DAR=4 : 3\n那么可以计算出PAR = DAR / SAR = 16 : 15，表示像素方格是一个长方形。\nFFmpeg提供了多个SAR：\nAVStream-\u0026gt;sample_aspect_ratio\nAVStream-\u0026gt;codecpar-\u0026gt;sample_aspect_ratio\nAVFrame-\u0026gt;sample_aspect_ratio\n最终的SAR是通过av_guess_sample_aspect_ratio获取的。\n对于DAR，AVStream-\u0026gt;display_aspect_ratio的值始终为0:0，参考ffprobe代码，可知DAR是通过av_reduce计算得到的，如下所示：\nAVRational sar, dar; // par AVCodecParameters *par = AVStream-\u0026gt;codecpar; // 计算出sar sar = av_guess_sample_aspect_ratio(AVFormatContext, AVStream, NULL); // 根据par和sar计算出dar av_reduce(\u0026amp;dar.num, \u0026amp;dar.den, par-\u0026gt;width * sar.num, par-\u0026gt;height * sar.den, 1024*1024); 查看音视频文件的数据包信息 # // -select_streams表示选择音频或者视频 ffprobe -show_format [-select_streams audio | video] inputFile 首先看下视频流的第一个Packet和第二个Packet：\n[PACKET] //Packet类型，即av_get_media_type_string(AVStream-\u0026gt;codecpar-\u0026gt;codec_type) codec_type=video // 当前帧所属流的索引信息,对应于AVStream-\u0026gt;index stream_index=0 // 帧展示时间，即AVPacket-\u0026gt;pts，基于AVStream-\u0026gt;time_base时间基准 pts=0 // 换算为秒 pts_time=0.000000 // 帧解码时间，即AVPacket-\u0026gt;dts，基于AVStream-\u0026gt;time_base时间基准 dts=0 // 换算为秒 dts_time=0.000000 // 当前帧的时长，等于下一帧的pts - 当前帧pts，即AVPacket-\u0026gt;duration，基于AVStream-\u0026gt;time_base时间基准 duration=12972 // 换算为秒 duration_time=0.144133 // AVPacket-\u0026gt;convergence_duration，也是基于AVStream-\u0026gt;time_base时间基准 convergence_duration=N/A // 换算为秒 convergence_duration_time=N/A // 当前帧的Size，字节，即AVPacket-\u0026gt;size size=187872 // 当前帧地址偏移量，即AVPacket-\u0026gt;pos pos=830842 flags=K_ [/PACKET] [PACKET] codec_type=video stream_index=0 pts=12972 // 即 12972 / 90000 pts_time=0.144133 dts=12972 dts_time=0.144133 duration=2999 duration_time=0.033322 convergence_duration=N/A convergence_duration_time=N/A size=31200 // 上一帧的pos + size pos=1018714 flags=__ [/PACKET] 然后看下音频流的第一个Packet和第二个Packet：\n[PACKET] // 音频帧 codec_type=audio // 当前帧所属流的索引信息,对应于AVStream-\u0026gt;index stream_index=1 // 帧展示时间，即AVPacket-\u0026gt;pts，基于AVStream-\u0026gt;time_base时间基准 pts=0 pts_time=0.000000 // 帧解码时间，即AVPacket-\u0026gt;dts，基于AVStream-\u0026gt;time_base时间基准 dts=0 dts_time=0.000000 // 当前帧的时长，等于下一帧的pts - 当前帧pts，即AVPacket-\u0026gt;duration，基于AVStream-\u0026gt;time_base时间基准 duration=1024 // 1024 / 48000 duration_time=0.021333 convergence_duration=N/A convergence_duration_time=N/A size=416 pos=810458 flags=K_ [/PACKET] [PACKET] // 音频帧 codec_type=audio stream_index=1 pts=1024 // 1024 / 48000 pts_time=0.021333 dts=1024 dts_time=0.021333 duration=1024 duration_time=0.021333 convergence_duration=N/A convergence_duration_time=N/A size=416 // 上一帧的pos + size pos=810874 flags=K_ [/PACKET] 查看音视频文件解码后的帧信息 # // -select_streams表示选择音频或者视频 ffprobe -show_frames [-select_streams audio | video] inputFile 首先看下视频流的第一帧和第二帧：\n[FRAME] // 帧类型，即av_get_media_type_string(AVStream-\u0026gt;codecpar-\u0026gt;codec_type) media_type=video // 当前帧所属流的索引信息, 对应于AVStream-\u0026gt;index stream_index=0 // 是否关键帧，1：关键帧，0：非关键帧，即AVFrame-\u0026gt;key_frame key_frame=1 // 帧展示时间, 即AVFrame-\u0026gt;pts, 基于AVStream-\u0026gt;time_base时间基准 pkt_pts=0 // 换算为秒 pkt_pts_time=0.000000 // 帧解码时间，从对应的AVPacket copy而来，即AVFrame-\u0026gt;pkt_dts，基于AVStream-\u0026gt;time_base时间基准 pkt_dts=0 // 换算为秒 pkt_dts_time=0.000000 // 帧时间戳，基本与pts相同，即AVFrame-\u0026gt;best_effort_timestamp，基于AVStream-\u0026gt;time_base时间基准 best_effort_timestamp=0 // 换算为秒 best_effort_timestamp_time=0.000000 // 对应的AVPacket的帧时长，即AVFrame-\u0026gt;pkt_duration，基于AVStream-\u0026gt;time_base时间基准 pkt_duration=12972 // 换算为秒 pkt_duration_time=0.144133 // 从最后一个已输入解码器的AVPacket重新排序的pos，即AVFrame-\u0026gt;pkt_pos pkt_pos=830842 // 对应的AVPacket的帧size，即AVFrame-\u0026gt;pkt_size pkt_size=187872 // 旋转之前的帧宽度，即AVFrame-\u0026gt;width width=1920 // 旋转之前的帧高度，即AVFrame-\u0026gt;height height=1080 // 视频帧的像素格式，即av_get_pix_fmt_name(AVFrame-\u0026gt;format) pix_fmt=yuvj420p // sar，图像采集时，横向采集点数与纵向采集点数的比例 // FFmpeg提供了多个sar：AVStream-\u0026gt;sample_aspect_ratio、AVStream-\u0026gt;codecpar-\u0026gt;sample_aspect_ratio、AVFrame-\u0026gt;sample_aspect_ratio // 通过av_guess_sample_aspect_ratio获取最终的sar sample_aspect_ratio=1:1 // 视频帧的图片类型，此处为I帧，即av_get_picture_type_char(frame-\u0026gt;pict_type) pict_type=I // picture number in bitstream order, 即AVFrame-\u0026gt;coded_picture_number coded_picture_number=0 // picture number in display order, 即AVFrame-\u0026gt;display_picture_number display_picture_number=0 // 视频帧内容是否是交错的, 即AVFrame-\u0026gt;interlaced_frame interlaced_frame=0 // 若视频帧内容是交错的，表示首先展示的顶部字段，即AVFrame-\u0026gt;top_field_first top_field_first=0 // 当解码时，这个信号表明视频帧必须延迟多少。extra_delay = repeat_pict / (2*fps), 即AVFrame-\u0026gt;repeat_pict repeat_pict=0 // 额外的色彩空间特征，即av_color_range_name(AVFrame-\u0026gt;color_range)，AVCOL_RANGE_MPEG对应tv，AVCOL_RANGE_JPEG对应pc color_range=pc // YUV彩色空间类型，即av_color_space_name(AVFrame-\u0026gt;colorspace) color_space=bt470bg // 即av_color_primaries_name(AVFrame-\u0026gt;color_primaries) color_primaries=bt470bg // 颜色传输特性，即av_color_transfer_name(AVFrame-\u0026gt;color_trc) color_transfer=smpte170m // 色度样品的位置，即av_chroma_location_name(AVFrame-\u0026gt;chroma_location) chroma_location=left [/FRAME] [FRAME] media_type=video stream_index=0 // 非关键帧 key_frame=0 pkt_pts=12972 // 12972 / 90000 pkt_pts_time=0.144133 pkt_dts=12972 pkt_dts_time=0.144133 best_effort_timestamp=12972 best_effort_timestamp_time=0.144133 pkt_duration=2999 pkt_duration_time=0.033322 pkt_pos=1018714 pkt_size=31200 width=1920 height=1080 pix_fmt=yuvj420p sample_aspect_ratio=1:1 // 视频帧的图片类型，此处为P帧，即av_get_picture_type_char(frame-\u0026gt;pict_type) pict_type=P coded_picture_number=1 display_picture_number=0 interlaced_frame=0 top_field_first=0 repeat_pict=0 color_range=pc color_space=bt470bg color_primaries=bt470bg color_transfer=smpte170m chroma_location=left [/FRAME] 然后看下音频流的第一帧和第二帧：\nFRAME] // 帧类型，即av_get_media_type_string(AVStream-\u0026gt;codecpar-\u0026gt;codec_type) media_type=audio // 当前帧所属流的索引信息, 对应于AVStream-\u0026gt;index stream_index=1 // 是否关键帧 key_frame=1 // 帧展示时间, 即AVFrame-\u0026gt;pts, 基于AVStream-\u0026gt;time_base时间基准 pkt_pts=0 // 换算为秒 pkt_pts_time=0.000000 // 帧解码时间，从对应的AVPacket copy而来，即AVFrame-\u0026gt;pkt_dts，基于AVStream-\u0026gt;time_base时间基准 pkt_dts=0 // 换算为秒 pkt_dts_time=0.000000 // 帧时间戳，基本与pts相同，即AVFrame-\u0026gt;best_effort_timestamp，基于AVStream-\u0026gt;time_base时间基准 best_effort_timestamp=0 // 换算为秒 best_effort_timestamp_time=0.000000 // 对应的AVPacket的帧时长，即AVFrame-\u0026gt;pkt_duration，基于AVStream-\u0026gt;time_base时间基准 pkt_duration=1024 // 换算为秒 pkt_duration_time=0.021333 // 从最后一个已输入解码器的AVPacket重新排序的pos，即AVFrame-\u0026gt;pkt_pos pkt_pos=810458 // 对应的AVPacket的帧size，即AVFrame-\u0026gt;pkt_size pkt_size=416 // 音频采样点格式，即av_get_sample_fmt_name(AVFrame-\u0026gt;format) sample_fmt=fltp // 当前音频帧的采样点数，即AVFrame-\u0026gt;nb_samples nb_samples=1024 // 通道数，即AVFrame-\u0026gt;channels channels=2 // 通道布局，通过av_bprint_channel_layout得到，与channels对应 channel_layout=stereo [/FRAME] [FRAME] media_type=audio stream_index=1 key_frame=1 pkt_pts=1024 pkt_pts_time=0.021333 pkt_dts=1024 pkt_dts_time=0.021333 best_effort_timestamp=1024 best_effort_timestamp_time=0.021333 pkt_duration=1024 pkt_duration_time=0.021333 pkt_pos=810874 pkt_size=416 sample_fmt=fltp nb_samples=1024 channels=2 channel_layout=stereo [/FRAME] 参考文章 # FFmpeg获取视频正确的宽高比\n转载自-\u0026gt;https://www.zybuluo.com/ltlovezh/note/1534824\n"},{"id":14,"href":"/notes/2018/11/07/bkiiygltx/","title":"📝 Operation not permitted","section":"📔 MacOS","content":" Rootless 机制\n报错 # Mac使用sudo或切换成root权限，还是出现\nOperation not permitted 解决 # 这是由于Mac的rootless机制，可以进入恢复模式关闭rootless机制：\n1、重启mac，按command+R（windows键盘：win+R）进入恢复模式\n2、选择终端，在左上角，输入指令：\ncsrutil disable 3、重启后让机器正常启动，可以在终端查看rootless状态：\ncsrutil status 正常情况下rootless已经关闭。\n4、要想重新开启rootless机制，参照步骤1，输入指令：\ncsrutil enable 说明 # 苹果从 OS X El Capitan 10.11 系统开始使用了 Rootless\n机制，可以将该机制理解为一个更高等级的系统的内核保护措施，系统默认将会锁定 /system、/sbin、/usr 这三个目录。\n"},{"id":15,"href":"/notes/2019/11/07/ovfeiboes/","title":"📝 FFmpeg删除元数据","section":"🔖 常用命令","content":" 清除mp3文件中自带的专辑（album），艺术家（artist），流派（genre）等元数据。\nffmpeg -i \u0026#34;test.mp3\u0026#34; -b:a 320k -map_metadata -1 -y \u0026#34;out.mp3\u0026#34; -map_metadata -1 表示清除所有元数据\n"},{"id":16,"href":"/notes/2018/06/21/bkwmi6d-7/","title":"📝 homebrew常用命令","section":"📔 MacOS","content":" brew常用的一些命令\n安装：ruby -e “$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)” 搜索：brew search XXX 在安装之前可以先查询一下，是否有这个软件 查询：brew info XXX 主要看具体的信息，比如目前的版本，依赖，安装后注意事项等 查看依赖： brew deps 查看包的依赖 安装：brew install xxx 用于安装软件 更新：brew update 这会更新 Homebrew 自己，并且使得接下来的两个操作有意义—— 检查过时（是否有新版本）：brew outdated 这回列出所有安装的软件里可以升级的那些 升级：brew upgrade 升级所有可以升级的软件们 清理：brew cleanup 清理不需要的版本极其安装包缓存 "},{"id":17,"href":"/notes/2018/11/27/h1mn7tca7/","title":"📝 FFmpeg裁剪视频","section":"🔖 常用命令","content":" ffmpeg命令裁剪视频，一般用于裁剪黑边\n命令 # ffmpeg -i input.mp4 -vf crop=iw/3:ih:0:0 output.mp4 ffmpeg -i input.mp4 -vf crop=iw/3:ih:iw/3:0 output.mp4 ffmpeg -i input.mp4 -vf crop=iw/3:ih:iw/3*2:0 output.mp4 "},{"id":18,"href":"/notes/2018/06/07/bkhoybugx/","title":"📝 MacOS pkg解包","section":"📔 MacOS","content":" jdk1.8.pkg解包\n每次安装Java的时候，都是一个pkg安装包，没有像linux下直接一个tar包那样绿色和方便。于是google搜索一下，终于找到解决的方法了。\nxar -xf JDK\\ 8\\ Update\\ 171.pkg cat jdk180171.pkg/Payload | cpio -i 是不是很简单，然后将”Contents/Home” 拷贝出来并重命名为jdk1.8，剩下的就和linux下配置java环境一样的了。\n"},{"id":19,"href":"/notes/2018/05/14/h1jgllvcl0g/","title":"📝 MacOS任何来源设置","section":"📔 MacOS","content":" 安装第三方软件必备技能\n打开终端 ( 终端在 应用程序 - 实用工具内 )\n输入以下命令并回车\nsudo spctl --master-disable 然后查看问题是否解决， 偏好设置-\u0026gt;安全性与隐私-\u0026gt;通用-\u0026gt;任何来源\n"},{"id":20,"href":"/notes/2018/08/30/bki3dandx/","title":"📝 FFmpeg 9:16和16:9互相转换","section":"🔖 常用命令","content":" ​今天搜集了一下16:9和9:16相互转换的命令。将多余的部分用模糊背景填充，感觉比直接加黑边好很多。\n16:9转9:16 # ffmpeg -i input.mp4 -lavfi \u0026#34;[0:v]scale=256/81*iw:256/81*ih,boxblur=luma_radius=min(h\\,w)/40:luma_power=3:chroma_radius=min(cw\\,ch)/40:chroma_power=1[bg];[bg][0:v]overlay=(W-w)/2:(H-h)/2,setsar=1,crop=w=iw*81/256\u0026#34; output.mp4 9:16转16:9 # ffmpeg -i input.mp4 -lavfi \u0026#39;[0:v]scale=ih*16/9:-1,boxblur=luma_radius=min(h\\,w)/20:luma_power=1:chroma_radius=min(cw\\,ch)/20:chroma_power=1[bg];[bg][0:v]overlay=(W-w)/2:(H-h)/2,crop=h=iw*9/16\u0026#39; -vb 800K output.mp4 "},{"id":21,"href":"/notes/2018/05/14/hkgt88e9u0f/","title":"📝 MacOS terminal清除历史命令纪录","section":"📔 MacOS","content":" Linux传统清除方式并没能解决\nhistory -c\n我用的iterm2 + zsh\n常用history命令：\n查看历史命令纪录:\nhistory…\nLinux传统清除方式并没能解决\nhistory -c 我用的iterm2 + zsh\n常用history命令： # 查看历史命令纪录:\nhistory\nhistory | less 使用 !! 执行上一条命令\n!! 使用 !foo 执行以 foo 开头的命令\n!foo 使用 !n 执行第 n 个命令\n!100\n可以尝试下这样来解决：\n在terminal中输入hist，然后tab键，出来以下这些\nHISTCHARS HISTFILE HISTSIZE\n了解历史记录的大小:\necho $HISTSIZE 历史记录的保存位置:\necho $HISTFILE # 查看history文件存放地址 echo \u0026gt; ~/.zsh_history # 清空 好了，退出terminal，重新登录检查一下即可 退出后，再history检查一下\n"},{"id":22,"href":"/notes/2018/07/27/skud1wo4x/","title":"📝 FFmbc传统输出格式","section":"🔖 常用命令","content":" 苹果ProRes # DVCPRO HD # # 将一个双声道音轨复制输出成两个单声道音轨 ffmbc -y -threads 8 -i 海外发行测试源文件0726.mp4 -target dvcprohd -tff -an 海外发行测试源文件0726-out.mxf -acodec pcm_s24le -ar 48000 -ac 1 -newaudio -acodec pcm_s24le -ar 48000 -newaudio -acodec pcm_s24le -ar 48000 # 将一个双声道音轨复制拆分成两个左右单声道音轨 ffmbc -y -threads 8 -i 海外发行测试源文件0726.mp4 -target dvcprohd -tff -an 海外发行测试源文件0726-out.mxf -acodec pcm_s24le -ar 48000 -newaudio -acodec pcm_s24le -ar 48000 -newaudio -map_audio_channel 0:1:0:0:1:0 -map_audio_channel 0:1:1:0:2:0 XDCAM HD422 # # ffmpeg ffmpeg -i test.mov -pix_fmt yuv422p -vcodec mpeg2video -non_linear_quant 1 -flags +ildct+ilme -top 1 -dc 10 -intra_vlc 1 -qmax 3 -lmin \u0026#34;1*QP2LAMBDA\u0026#34; -vtag xd5c -rc_max_vbv_use 1 -rc_min_vbv_use 1 -g 12 -b:v 50000k -minrate 50000k -maxrate 50000k -bufsize 8000k -acodec pcm_s16le -ar 48000 -bf 2 -ac 2 -f mxf_d10 output.mxf # ffmbc ffmbc -y -threads 8 -i 先导片.mp4 -target xdcamhd422 -tff -acodec pcm_s24le 先导片-out.mov "},{"id":23,"href":"/notes/2018/05/14/bjdz88n580g/","title":"📝 FFmpeg逐行转隔行","section":"🔖 常用命令","content":" 命令参数 # ffmpeg -i input -aspect 16:9 -c:v mpeg2video -b:v 4000k -minrate 4000k -maxrate 4000k -bufsize 2000k -dc 9 -flags +ilme+ildct -alternate_scan 1 -top 0 output 其实主要的就是如下参数：\n-flags +ilme+ildct -alternate_scan 1 -top 0 alternate_scan使用隔行转码，top不一般没有什么要求的话頂场优先就可以了。\n隔行转逐行 # ffmpeg -i input -aspect 16:9 -c:v mpeg2video -b:v 4000k -minrate 4000k -maxrate 4000k -bufsize 2000k -dc 9 -deinterlace output 添加一个“deinterlace”即可。\n"},{"id":24,"href":"/links/","title":"🤝 友情链接","section":"Docs","content":" "},{"id":25,"href":"/articles/2024/03/27/e4c2nybngzu5eddbnmdjgq/","title":"Mamba替代Conda","section":"📚 我的文章","content":"mamba是一个conda的替代品，可以加速conda的包管理，提升包管理的效率。\n安装 # brew install micromamba 配置 # # 根据命令提示，修改~/.zshrc文件 micromamba shell init -s zsh -p ~/.micromamba # 添加配置文件 $ cat ~/.mambarc channels: - conda-forge always_yes: false 使用 # micromamba create -n python310 python=3.10 # 激活环境 micromamba activate python310 # 然后可以用 micromamba 或者 pip 装东西 micromamba install package_1 package_2=version ## 具体请参考 https://mamba.readthedocs.io/en/latest/ micromamba --help "},{"id":26,"href":"/articles/2024/03/06/9mzhfnl58azjmeibfblvjy/","title":"Hugo网站建设","section":"📚 我的文章","content":" 安装 Hugo # 下载地址：https://github.com/gohugoio/hugo/releases\n创建网站 # hugo new site book cd book git init git submodule add https://github.com/alex-shpak/hugo-book themes/hugo-book 本地调试 # hugo server --disableFastRender --minify --ignoreCache github actions # mkdir -p .github/workflows touch .github/workflows/build.yml name: Build on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.04 concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v3 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.123.7\u0026#39; # 是否启用 hugo extend extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == \u0026#39;refs/heads/main\u0026#39; }} with: github_token: ${{ secrets.GH_PAGE_ACTION_TOKEN }} publish_dir: ./public github pages # 可以在项目的 Settings 中开启 Pages 服务，然后选择 Branch 为gh-pages即可。\n如果想要定制域名，可以参考官方文档 About custom domains and GitHub Pages\n"}]